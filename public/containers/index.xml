<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker :: Learn containers</title>
    <link>https://khushiramsingh680.github.io/containers/containers/index.html</link>
    <description>Docker – Table of Contents 1. Linux Kernel &amp; Container Fundamentals Namespaces → PID, Mount, Network, IPC, UTS, User cgroups → CPU, Memory, I/O, PIDs limits Filesystem isolation with chroot Experimenting with unshare to create isolated environments How Docker and Podman use namespaces and cgroups internally 2. Introduction What is Docker? Benefits of containerization Docker vs Virtual Machines Containers vs Low-Level Runtimes (CRI-O, containerd) 3. Installation &amp; Setup Install Docker on Linux, Windows, macOS Docker Desktop Docker Engine vs Docker Desktop Verify installation 4. Docker Architecture Docker Daemon Docker Client Docker Images Docker Containers Docker Registries (Docker Hub, private registries) Low-level container runtimes: CRI-O &amp; containerd 5. Working with Docker Images Building images with Dockerfile Using prebuilt images Managing images (docker pull, docker images, docker rmi) Image layers &amp; storage drivers 6. Working with Containers Running containers (docker run) Listing, starting, stopping, removing containers Detached mode &amp; interactive mode Executing commands inside containers Understanding isolation using namespaces Resource control using cgroups Low-level experiments with unshare and chroot 7. Docker Networking Bridge network Host network Overlay network Custom networks Port mapping &amp; exposing services Network namespaces overview 8. Docker Volumes &amp; Storage Bind mounts vs volumes Creating and using volumes Sharing data between containers Backup &amp; restore volumes Storage namespaces &amp; container filesystem isolation 9. Docker Compose Introduction to Compose docker-compose.yml structure Multi-container applications Environment variables &amp; scaling 10. Docker Security Best practices User namespaces Scanning images Secrets management Seccomp &amp; AppArmor profiles 11. Docker in CI/CD Using Docker in pipelines Building and pushing images Deploying with Docker Integration with Kubernetes using CRI-O/containerd 12. Advanced Docker Multi-stage builds Health checks Resource limits (CPU &amp; memory) Logging &amp; monitoring Low-level runtime configuration 13. Troubleshooting Common errors Debugging containers Checking logs &amp; events Using docker inspect and runtime debug tools 14. Docker vs Alternatives Podman LXC/LXD CRI-O &amp; containerd</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://khushiramsingh680.github.io/containers/containers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>part 01</title>
      <link>https://khushiramsingh680.github.io/containers/containers/container01/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/container01/index.html</guid>
      <description>Topics 1. Linux Namespaces 2. Linux Cgroups 3. Unshare 4. chroot Introduction: What Are Linux Namespaces? By default, all processes on a Linux system share the same namespaces for things like process IDs, network, mounts, etc. This means:&#xA;All processes see the same list of processes. All processes share the same network interfaces and IP addresses. All processes see the same filesystem mount points. All processes share the same hostname. Why Do We Need Namespaces? Namespaces allow the Linux kernel to isolate and virtualize system resources so that a group of processes can have their own view of the system. This is key for:</description>
    </item>
    <item>
      <title>Part 02</title>
      <link>https://khushiramsingh680.github.io/containers/containers/conatiner02/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/conatiner02/index.html</guid>
      <description>Open Container Initiative (OCI) and Container Standards What is OCI? The Open Container Initiative (OCI) is an open governance project under the Linux Foundation started in 2015. It creates open standards for container formats and runtimes to ensure interoperability and portability across container platforms.&#xA;Key OCI Specifications OCI Image Format Specification&#xA;Defines a standard image format including layers, manifests, and metadata so images are portable across tools.&#xA;OCI Runtime Specification&#xA;Defines how to run containers using namespaces, cgroups, hooks, and other OS features.</description>
    </item>
    <item>
      <title>Part 03</title>
      <link>https://khushiramsingh680.github.io/containers/containers/container03/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/container03/index.html</guid>
      <description>Docker Architecture – Workflow +----------------+ Unix Socket / REST API +----------------+ | Docker Client | ----------------------------&gt; | Docker Daemon | | (CLI / GUI) | | (dockerd) | +----------------+ +----------------+ | | Uses container runtime (containerd) v +-----------------------+ | Container Runtime | | (containerd / CRI-O) | +-----------------------+ | | Creates &amp; manages v +-----------------------+ | Containers | | (Running Apps) | +-----------------------+ ^ | Images | +-----------------------+ | Docker Registry | | (Docker Hub / Private)| +-----------------------+&#xD;Docker CLI | v Docker Daemon (dockerd) | v containerd (high-level runtime) | v runc (low-level runtime, OCI-compliant) | v Linux Kernel (namespaces, cgroups, filesystem)&#xD;Components Explained 1. Docker Client (CLI) Interface to interact with Docker (docker run, docker build). Sends commands to Docker daemon via: Unix socket (/var/run/docker.sock) TCP/REST API (optional, for remote management) 2. Docker Daemon (dockerd) Background service managing containers, images, networks, and volumes. Receives commands from CLI. Delegates container creation to the container runtime. 3. Container Runtime Low-level manager responsible for running containers. Docker uses containerd by default. Handles: Image unpacking Container lifecycle Storage and logging Communicates with daemon via API or socket. 4 Low-level Runtime The low-level runtime is responsible for actually creating and running containers on the host OS. runc is the default low-level runtime used by Docker, containerd, and CRI-O. Responsibilities of the low-level runtime: Creating namespaces for process isolation Managing cgroups for resource limits Mounting filesystems for container file isolation Directly interacting with the Linux kernel to run containers It implements the OCI runtime specification, ensuring containers are standardized and portable. High-level runtimes like containerd or CRI-O call the low-level runtime to execute containers. 5. Docker Registries Store and distribute container images. Docker Hub: Public registry. Private registries: Internal organization use. Commands: docker pull, docker push. 6. Communication Flow User runs docker run nginx. CLI sends request via Unix socket to daemon. Daemon pulls image from registry (if needed). Daemon delegates container creation to containerd. containerd interacts with OS kernel to start the container. Daemon sends container info back to CLI. 7. Socket Exposure Unix socket: /var/run/docker.sock (local access, secure) TCP socket: tcp://0.0.0.0:2375 (remote access, insecure) Kubernetes CRI sockets: CRI-O: /var/run/crio/crio.sock containerd: /run/containerd/containerd.sock</description>
    </item>
    <item>
      <title>Part 04</title>
      <link>https://khushiramsingh680.github.io/containers/containers/container04/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/container04/index.html</guid>
      <description>1. Container Related commands Commands Lifecycle docker run [OPTIONS] IMAGE [COMMAND] [ARG...] docker run -d -p 8080:80 --name webserver nginx docker start CONTAINER_NAME_OR_ID docker stop CONTAINER_NAME_OR_ID docker restart CONTAINER_NAME_OR_ID docker rm CONTAINER_NAME_OR_ID docker rm -f CONTAINER_NAME_OR_ID docker pause CONTAINER_NAME docker unpause CONTAINER_NAME docker kill CONTAINER_NAME&#xD;Monitoring &amp; Inspection docker ps docker ps -a docker inspect CONTAINER_NAME docker logs CONTAINER_NAME docker logs -f CONTAINER_NAME docker stats docker stats CONTAINER_NAME docker exec -it CONTAINER_NAME bash docker attach CONTAINER_NAME docker top CONTAINER_NAME docker exec CONTAINER_NAME env docker inspect -f &#39;{{ .Mounts }}&#39; CONTAINER_NAME&#xD;Management docker network inspect NETWORK_NAME docker network connect NETWORK_NAME CONTAINER_NAME docker network disconnect NETWORK_NAME CONTAINER_NAME docker run --network NETWORK_NAME IMAGE_NAME&#xD;misc docker run -it IMAGE_NAME bash docker run -d IMAGE_NAME docker run -d --name limited_container --memory=&#34;512m&#34; --cpus=&#34;1.0&#34; IMAGE_NAME docker ps -q -f ancestor=IMAGE_NAME&#xD;Install mysql in docker</description>
    </item>
  </channel>
</rss>