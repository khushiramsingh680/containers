<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker :: Learn containers</title>
    <link>https://khushiramsingh680.github.io/containers/containers/index.html</link>
    <description>Please click Here to connect Docker – Table of Contents 1. Linux Kernel &amp; Container Fundamentals Namespaces → PID, Mount, Network, IPC, UTS, User cgroups → CPU, Memory, I/O, PIDs limits Filesystem isolation with chroot Experimenting with unshare to create isolated environments How Docker and Podman use namespaces and cgroups internally 2. Introduction What is Docker? Benefits of containerization Docker vs Virtual Machines Containers vs Low-Level Runtimes (CRI-O, containerd) 3. Installation &amp; Setup Install Docker on Linux, Windows, macOS Docker Desktop Docker Engine vs Docker Desktop Verify installation 4. Docker Architecture Docker Daemon Docker Client Docker Images Docker Containers Docker Registries (Docker Hub, private registries) Low-level container runtimes: CRI-O &amp; containerd 5. Working with Docker Images Building images with Dockerfile Using prebuilt images Managing images (docker pull, docker images, docker rmi) Image layers &amp; storage drivers 6. Working with Containers Running containers (docker run) Listing, starting, stopping, removing containers Detached mode &amp; interactive mode Executing commands inside containers Understanding isolation using namespaces Resource control using cgroups Low-level experiments with unshare and chroot 7. Docker Networking Bridge network Host network Overlay network Custom networks Port mapping &amp; exposing services Network namespaces overview 8. Docker Volumes &amp; Storage Bind mounts vs volumes Creating and using volumes Sharing data between containers Backup &amp; restore volumes Storage namespaces &amp; container filesystem isolation 9. Docker Compose Introduction to Compose docker-compose.yml structure Multi-container applications Environment variables &amp; scaling 10. Docker Security Best practices User namespaces Scanning images Secrets management Seccomp &amp; AppArmor profiles 11. Docker in CI/CD Using Docker in pipelines Building and pushing images Deploying with Docker Integration with Kubernetes using CRI-O/containerd 12. Advanced Docker Multi-stage builds Health checks Resource limits (CPU &amp; memory) Logging &amp; monitoring Low-level runtime configuration 13. Troubleshooting Common errors Debugging containers Checking logs &amp; events Using docker inspect and runtime debug tools 14. Docker vs Alternatives Podman LXC/LXD CRI-O &amp; containerd</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://khushiramsingh680.github.io/containers/containers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>part 01</title>
      <link>https://khushiramsingh680.github.io/containers/containers/container01/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/container01/index.html</guid>
      <description>Topics 1. Linux Namespaces 2. Linux Cgroups 3. Unshare 4. chroot Introduction: What Are Linux Namespaces? By default, all processes on a Linux system share the same namespaces for things like process IDs, network, mounts, etc. This means:&#xA;All processes see the same list of processes. All processes share the same network interfaces and IP addresses. All processes see the same filesystem mount points. All processes share the same hostname. Why Do We Need Namespaces? Namespaces allow the Linux kernel to isolate and virtualize system resources so that a group of processes can have their own view of the system. This is key for:</description>
    </item>
    <item>
      <title>Part 02</title>
      <link>https://khushiramsingh680.github.io/containers/containers/conatiner02/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/conatiner02/index.html</guid>
      <description>Open Container Initiative (OCI) and Container Standards What is OCI? The Open Container Initiative (OCI) is an open governance project under the Linux Foundation started in 2015. It creates open standards for container formats and runtimes to ensure interoperability and portability across container platforms.&#xA;Key OCI Specifications OCI Image Format Specification&#xA;Defines a standard image format including layers, manifests, and metadata so images are portable across tools.&#xA;OCI Runtime Specification&#xA;Defines how to run containers using namespaces, cgroups, hooks, and other OS features.</description>
    </item>
    <item>
      <title>Part 03</title>
      <link>https://khushiramsingh680.github.io/containers/containers/container03/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/container03/index.html</guid>
      <description>Docker Architecture – Workflow +----------------+ Unix Socket / REST API +----------------+ | Docker Client | ----------------------------&gt; | Docker Daemon | | (CLI / GUI) | | (dockerd) | +----------------+ +----------------+ | | Uses container runtime (containerd) v +-----------------------+ | Container Runtime | | (containerd / CRI-O) | +-----------------------+ | | Creates &amp; manages v +-----------------------+ | Containers | | (Running Apps) | +-----------------------+ ^ | Images | +-----------------------+ | Docker Registry | | (Docker Hub / Private)| +-----------------------+&#xD;Docker CLI | v Docker Daemon (dockerd) | v containerd (high-level runtime) | v runc (low-level runtime, OCI-compliant) | v Linux Kernel (namespaces, cgroups, filesystem)&#xD;Components Explained 1. Docker Client (CLI) Interface to interact with Docker (docker run, docker build). Sends commands to Docker daemon via: Unix socket (/var/run/docker.sock) TCP/REST API (optional, for remote management) 2. Docker Daemon (dockerd) Background service managing containers, images, networks, and volumes. Receives commands from CLI. Delegates container creation to the container runtime. 3. Container Runtime Low-level manager responsible for running containers. Docker uses containerd by default. Handles: Image unpacking Container lifecycle Storage and logging Communicates with daemon via API or socket. 4 Low-level Runtime The low-level runtime is responsible for actually creating and running containers on the host OS. runc is the default low-level runtime used by Docker, containerd, and CRI-O. Responsibilities of the low-level runtime: Creating namespaces for process isolation Managing cgroups for resource limits Mounting filesystems for container file isolation Directly interacting with the Linux kernel to run containers It implements the OCI runtime specification, ensuring containers are standardized and portable. High-level runtimes like containerd or CRI-O call the low-level runtime to execute containers. 5. Docker Registries Store and distribute container images. Docker Hub: Public registry. Private registries: Internal organization use. Commands: docker pull, docker push. 6. Communication Flow User runs docker run nginx. CLI sends request via Unix socket to daemon. Daemon pulls image from registry (if needed). Daemon delegates container creation to containerd. containerd interacts with OS kernel to start the container. Daemon sends container info back to CLI. 7. Socket Exposure Unix socket: /var/run/docker.sock (local access, secure) TCP socket: tcp://0.0.0.0:2375 (remote access, insecure) Kubernetes CRI sockets: CRI-O: /var/run/crio/crio.sock containerd: /run/containerd/containerd.sock</description>
    </item>
    <item>
      <title>Part 04</title>
      <link>https://khushiramsingh680.github.io/containers/containers/container04/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/container04/index.html</guid>
      <description>1. Container Related commands Commands Lifecycle docker run [OPTIONS] IMAGE [COMMAND] [ARG...] docker run -d -p 8080:80 --name webserver nginx docker start CONTAINER_NAME_OR_ID docker stop CONTAINER_NAME_OR_ID docker restart CONTAINER_NAME_OR_ID docker rm CONTAINER_NAME_OR_ID docker rm -f CONTAINER_NAME_OR_ID docker pause CONTAINER_NAME docker unpause CONTAINER_NAME docker kill CONTAINER_NAME&#xD;Monitoring &amp; Inspection docker ps docker ps -a docker inspect CONTAINER_NAME docker logs CONTAINER_NAME docker logs -f CONTAINER_NAME docker stats docker stats CONTAINER_NAME docker exec -it CONTAINER_NAME bash docker attach CONTAINER_NAME docker top CONTAINER_NAME docker exec CONTAINER_NAME env docker inspect -f &#39;{{ .Mounts }}&#39; CONTAINER_NAME&#xD;Management docker network inspect NETWORK_NAME docker network connect NETWORK_NAME CONTAINER_NAME docker network disconnect NETWORK_NAME CONTAINER_NAME docker run --network NETWORK_NAME IMAGE_NAME&#xD;misc docker run -it IMAGE_NAME bash docker run -d IMAGE_NAME docker run -d --name limited_container --memory=&#34;512m&#34; --cpus=&#34;1.0&#34; IMAGE_NAME docker ps -q -f ancestor=IMAGE_NAME&#xD;Install mysql in docker</description>
    </item>
    <item>
      <title>Part 05</title>
      <link>https://khushiramsingh680.github.io/containers/containers/container05/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/container05/index.html</guid>
      <description>Docker Restart Policies &amp; Types of Containers 1. Docker Restart Policies Restart policies define how Docker should handle container restarts when they exit or the Docker daemon restarts.&#xA;Types of Restart Policies no (default)&#xA;Container does not restart automatically. Example: docker run --restart=no nginx&#xD;on-failure&#xA;Restarts container only if it exits with a non-zero exit code (error). Optionally, you can limit retries (e.g., on-failure:5). Example: docker run --restart=on-failure:3 myapp&#xD;always</description>
    </item>
    <item>
      <title>Part 06</title>
      <link>https://khushiramsingh680.github.io/containers/containers/container06-/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/container06-/index.html</guid>
      <description>Docker file Click Here for Dockerfile Docker Compose Click Here of Docker Compose Docker Monitoring Prometheus Grafana Grafana Loki Portainer</description>
    </item>
    <item>
      <title>Part 07</title>
      <link>https://khushiramsingh680.github.io/containers/containers/container07/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/container07/index.html</guid>
      <description>Docker Security Docker security is about protecting containers, images, the Docker daemon, host system, and networks from vulnerabilities or misuse. It requires best practices at all layers.&#xA;1. Image Security Use official/trusted images only. Keep images small &amp; minimal (Alpine, distroless). Scan images for vulnerabilities: docker scan myimage:latest Enable Docker Content Trust (DCT) to sign &amp; verify images: export DOCKER_CONTENT_TRUST=1 2. Container Security Run as non-root user: USER 1001 (in Dockerfile) Avoid –privileged containers (full host access). Use read-only filesystem: docker run –read-only nginx Limit resources (cgroups): docker run -m 512m –cpus=“1.0” nginx Drop capabilities: docker run –cap-drop=ALL –cap-add=NET_BIND_SERVICE nginx 3. Docker Daemon Security Prefer rootless mode for Docker. Protect /var/run/docker.sock (limit access). Use TLS for Docker API: dockerd –tlsverify –tlscacert=ca.pem –tlscert=server-cert.pem –tlskey=server-key.pem -H=0.0.0.0:2376 4. Network Security Use user-defined networks for isolation. Encrypt overlay networks for multi-host. Restrict exposed ports (-p flag). Apply firewall rules (iptables, ufw). 5. Host Security Keep OS &amp; Docker updated. Enable AppArmor or SELinux. Restrict root access on host. For strong isolation → run containers inside VMs. 6. Security Tools Docker Bench for Security – Audits configs: docker run -it –net host –pid host –cap-add audit_control -v /var/lib:/var/lib -v /var/run/docker.sock:/var/run/docker.sock -v /usr/lib/systemd:/usr/lib/systemd -v /etc:/etc docker/docker-bench-security Trivy / Clair / Anchore – Image scanning. Falco – Runtime monitoring. 7. Seccomp Profiles Restrict Linux syscalls with seccomp. Example: docker run –security-opt seccomp=/path/to/profile.json nginx 8. Rootless Docker Run daemon &amp; containers without root → reduces attack surface. Install: curl -fsSL https://get.docker.com/rootless | sh 9. Best Practices (Quick Checklist ✅) Use minimal, signed images Run containers as non-root Drop privileges &amp; capabilities Use TLS for API Patch host &amp; Docker regularly Scan images before use Monitor containers at runtime Creating a Container with Full Host Access ⚠️ Warning: This setup gives the container root-level access to the host. Use only on safe environments or lab machines. Misuse can compromise the host system.</description>
    </item>
    <item>
      <title>Project 01</title>
      <link>https://khushiramsingh680.github.io/containers/containers/project01.md/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/project01.md/index.html</guid>
      <description>——————————- 1. DB Server Configuration ——————————- yum install mariadb-server -y systemctl enable mariadb systemctl start mariadb&#xD;Configure Database mysql -e &#34; CREATE DATABASE studentapp; USE studentapp; CREATE TABLE Students ( student_id INT NOT NULL AUTO_INCREMENT, student_name VARCHAR(100) NOT NULL, student_addr VARCHAR(100) NOT NULL, student_age VARCHAR(3) NOT NULL, student_qual VARCHAR(20) NOT NULL, student_percent VARCHAR(10) NOT NULL, student_year_passed VARCHAR(10) NOT NULL, PRIMARY KEY (student_id) ); GRANT ALL PRIVILEGES ON studentapp.* TO &#39;student&#39;@&#39;%&#39; IDENTIFIED BY &#39;student@1&#39;; FLUSH PRIVILEGES; &#34;&#xD;——————————- 2. Tomcat (Application Server) ——————————- yum install java -y cd /root wget -qO- http://www-us.apache.org/dist/tomcat/tomcat-8/v8.5.27/bin/apache-tomcat-8.5.27.tar.gz | tar -xz cd apache-tomcat-8.5.27 rm -rf webapps/* wget https://github.com/cit-latex/stack/raw/master/mysql-connector-java-5.1.40.jar -O lib/mysql-connector-java-5.1.40.jar wget https://github.com/cit-latex/stack/raw/master/student.war -O webapps/student.war&#xD;Edit context.xml (replace accordingly) &lt;Resource name=&#34;jdbc/TestDB&#34; auth=&#34;Container&#34; type=&#34;javax.sql.DataSource&#34; maxTotal=&#34;100&#34; maxIdle=&#34;30&#34; maxWaitMillis=&#34;10000&#34; username=&#34;student&#34; password=&#34;student@1&#34; driverClassName=&#34;com.mysql.jdbc.Driver&#34; url=&#34;jdbc:mysql://172.17.0.2:3306/studentapp&#34;/&gt; &lt;/Context&gt;&#xD;Start Tomcat sh bin/startup.sh</description>
    </item>
    <item>
      <title>Projects</title>
      <link>https://khushiramsingh680.github.io/containers/containers/projects/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://khushiramsingh680.github.io/containers/containers/projects/index.html</guid>
      <description>Projects Use Nexus as a Docker Registry Task 01: Nexus as a Container Registry Objectives: Install Nexus as a Docker image, login, and push images.&#xA;Solution Step 1: Run Nexus in Docker mkdir -p ~/nexus-data &amp;&amp; chmod 777 ~/nexus-data docker run -d --name nexus -p 8081:8081 -p 5000:5000 -v ~/nexus-data:/nexus-data sonatype/nexus3 Access Nexus UI: http://localhost:8081&#xA;Default admin credentials: admin / password in ~/nexus-data/admin.password&#xA;Step 2: Create a Private Docker Registry in Nexus</description>
    </item>
  </channel>
</rss>